<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Attack</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #222;
            color: #eee;
            overflow: hidden; /* Prevent scrollbars */
        }

        #game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #ui-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 10px;
            font-size: 1.2em;
            padding: 0 10px;
        }

        #score, #chain {
             background-color: #444;
             padding: 5px 15px;
             border-radius: 5px;
        }

        #game-board {
            position: relative;
            width: 240px; /* 6 columns * 40px */
            height: 480px; /* 12 rows * 40px */
            background-color: #111;
            border: 2px solid #555;
            overflow: hidden; /* Crucial for hiding blocks above the top */
        }

        .block {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            /* Transition for falling and swapping, NOT for top/left during continuous rise */
            transition: top 0.1s ease-out, left 0.1s ease-out, transform 0.1s ease-out, opacity 0.1s ease-in;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
            /* transform for continuous rise offset */
            transform: translateY(0px);
            will-change: transform, top, left; /* Optimization hint */
        }

        /* Simple block colors/styles */
        .block-type-0 { background-color: #FF5733; } /* Red */
        .block-type-1 { background-color: #33FF57; } /* Green */
        .block-type-2 { background-color: #3357FF; } /* Blue */
        .block-type-3 { background-color: #FFFF33; } /* Yellow */
        .block-type-4 { background-color: #FF33FF; } /* Magenta */
        .block-type-5 { background-color: #33FFFF; } /* Cyan */

        .block.falling {
             /* Falling uses 'top' property transition */
             transition: top 0.15s ease-in, left 0.1s ease-out, opacity 0.1s ease-in;
             transform: translateY(0px) !important; /* Override rise transform during fall */
        }

        .block.swapping {
             /* Swapping uses 'left' property transition */
             transition: left 0.08s linear, top 0.1s ease-out, opacity 0.1s ease-in;
             transform: translateY(0px) !important; /* Override rise transform during swap */
        }

        .block.flashing {
            animation: flash 0.4s infinite alternate;
            /* Ensure transform doesn't interfere with flash scaling */
             /* transform-origin: center center; (usually default) */
        }

        @keyframes flash {
            0% { opacity: 1; transform: scale(1.05); box-shadow: 0 0 10px white; }
            100% { opacity: 0.5; transform: scale(1); box-shadow: none; }
        }
        /* Note: Flash animation might conflict visually with translateY. Careful testing needed. */
        /* If conflict, might need to apply translateY to a wrapper element instead. */


        #cursor {
            position: absolute;
            width: 80px; /* 2 blocks wide */
            height: 40px; /* 1 block high */
            border: 3px solid #FFF;
            pointer-events: none; /* Don't interfere with clicks */
            transition: top 0.05s linear, left 0.05s linear;
            z-index: 10;
            box-shadow: 0 0 8px #FFF;
            /* Cursor also needs to move with the rise */
             transform: translateY(0px);
             will-change: transform, top, left;
        }

        #game-over-overlay, #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            z-index: 20;
        }

        #game-over-overlay h2, #start-overlay h2 {
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        #game-over-overlay p, #start-overlay p {
            font-size: 1.2em;
            margin-bottom: 25px;
        }

        #game-over-overlay button, #start-overlay button {
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            background-color: #4CAF50;
            border: none;
            color: white;
            border-radius: 5px;
            transition: background-color 0.2s;
        }

        #game-over-overlay button:hover, #start-overlay button:hover {
            background-color: #45a049;
        }
        #start-overlay p.controls {
            margin-top: 20px;
            font-size: 0.9em;
            color: #ccc;
            max-width: 80%;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-panel">
            <div id="score">Score: 0</div>
            <div id="chain">Chain: x0</div>
        </div>
        <div id="game-board">
            <div id="cursor"></div>
            <!-- Blocks will be added here by JavaScript -->
        </div>
    </div>

    <div id="start-overlay">
        <h2>Block Attack</h2>
        <p>Clear blocks by matching 3 or more!</p>
         <p class="controls">Controls:<br>Arrow Keys: Move Cursor<br>Spacebar / X: Swap Blocks</p>
        <button id="start-button">Start Game</button>
    </div>

    <div id="game-over-overlay" style="display: none;">
        <h2>Game Over</h2>
        <p id="final-score">Final Score: 0</p>
        <button id="restart-button">Restart</button>
    </div>

    <script>
        // --- Game Constants ---
        const GRID_WIDTH = 6;
        const GRID_HEIGHT = 12; // Playable rows (logical grid height)
        const VISIBLE_GRID_HEIGHT = 12; // How many rows are visible on screen
        const BLOCK_SIZE = 40; // px
        const BLOCK_TYPES = 6; // Number of different block colors/types
        const MIN_MATCH_LENGTH = 3;

        // --- Continuous Rise Constants ---
        const INITIAL_RISE_SPEED = BLOCK_SIZE / 5.0; // Pixels per second (e.g., 1 block every 5 seconds)
        const MAX_RISE_SPEED = BLOCK_SIZE / 0.5;   // Pixels per second (e.g., 1 block every 0.5 seconds)
        const RISE_ACCELERATION = 0.5; // Pixels per second to add *per second* (or adjust based on time/events)
        // Alternative: Increase speed slightly every time a row commits
        const SPEED_INCREMENT_ON_COMMIT = 1.0; // Pixels per second increase


        const FLASH_DURATION = 400; // ms for blocks to flash
        const INDIVIDUAL_REMOVE_DELAY = 50; // ms between each block vanishing in a match
        const FALL_DURATION = 150; // ms for falling animation (matches CSS)
        const SWAP_DURATION = 80; // ms for swap animation (matches CSS)

        // --- DOM Elements ---
        const gameBoard = document.getElementById('game-board');
        const cursorElement = document.getElementById('cursor');
        const scoreElement = document.getElementById('score');
        const chainElement = document.getElementById('chain');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const finalScoreElement = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const startOverlay = document.getElementById('start-overlay');
        const startButton = document.getElementById('start-button');

        // --- Game State ---
        let grid = []; // 2D array representing block types (or null for empty) - GRID_HEIGHT+1 tall for buffer
        let blocks = []; // Array of block objects { element, row, col, type, id, state }
        let cursor = { row: 5, col: 2 }; // Initial cursor position (logical row)
        let score = 0;
        let currentChain = 0;
        let isGameOver = false;
        let isProcessing = false; // Flag to manage sequential processing (clearing, falling)
        let nextBlockId = 0;
        let activeClearPromises = [];

        // --- Continuous Rise State ---
        let riseOffset = 0; // Current pixel offset for the continuous rise (0 to BLOCK_SIZE)
        let currentRiseSpeed = INITIAL_RISE_SPEED; // Pixels per second
        let lastTimestamp = 0; // For calculating delta time in animation loop
        let animationFrameId = null; // To control the animation loop


        // --- Audio Assets (Placeholders) ---
        const swapSound = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+Array(100).join('100'));
        const clearSound = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+Array(150).join('123'));
        const gameOverSound = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU'+Array(300).join('987'));
        let audioContextAllowed = false;

        function playSound(sound) {
             if (!audioContextAllowed) return;
             sound.currentTime = 0;
             sound.play().catch(e => console.warn("Audio play failed:", e));
         }


        // --- Game Initialization ---
        function initGame() {
            console.log("Initializing game...");
            isGameOver = false;
            isProcessing = false;
            score = 0;
            currentChain = 0;
            cursor = { row: 5, col: 2 };
            nextBlockId = 0;
            activeClearPromises = [];

            // Reset rise state
            riseOffset = 0;
            currentRiseSpeed = INITIAL_RISE_SPEED;
            lastTimestamp = 0;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            // Clear existing DOM elements
            gameBoard.querySelectorAll('.block').forEach(el => el.remove());

            // Initialize grid and blocks array (GRID_HEIGHT + 1 for buffer row at the top)
            grid = Array(GRID_HEIGHT + 1).fill(null).map(() => Array(GRID_WIDTH).fill(null));
            blocks = [];

            // Create initial stack (e.g., bottom 5 rows)
            for (let r = 0; r < 5; r++) {
                // Generate row data WITHOUT rendering yet
                generateNewRowData(r);
            }
             // Add empty rows above initial stack in the model
            for(let r = 5; r < GRID_HEIGHT + 1; r++){ // Include buffer row
                 for(let c = 0; c < GRID_WIDTH; c++){
                     grid[r][c] = null;
                 }
            }

            // Now render all initial blocks
            blocks.forEach(renderBlock);

            updateScoreDisplay();
            updateChainDisplay();
            renderCursor(); // Render cursor based on logical position and current riseOffset

            gameOverOverlay.style.display = 'none';
            startOverlay.style.display = 'none';
            cursorElement.style.display = 'block'; // Show cursor

            console.log("Game initialized. Starting continuous rise.");
            // Start the continuous rise animation loop
            startGameLoop();

            // Check initial matches
            checkMatchesAndProcess();
        }

        // --- Rendering Functions ---
        function renderBlock(blockData) {
            const blockElement = document.createElement('div');
            blockElement.classList.add('block', `block-type-${blockData.type}`);
            blockElement.dataset.id = blockData.id; // Assign unique ID
            blockData.element = blockElement; // Store element reference
            updateBlockVisualPosition(blockData); // Set initial position including rise offset
            gameBoard.appendChild(blockElement);
        }

        // Updates both CSS 'top'/'left' and 'transform' for rise offset
        function updateBlockVisualPosition(blockData) {
            if (!blockData.element) return;

            // Base position from logical row/col
            const baseX = blockData.col * BLOCK_SIZE;
            const baseY = (VISIBLE_GRID_HEIGHT - 1 - blockData.row) * BLOCK_SIZE;

            blockData.element.style.left = `${baseX}px`;
            blockData.element.style.top = `${baseY}px`;

            // Apply vertical offset for continuous rise, unless falling or swapping
             if (blockData.state !== 'falling' && blockData.state !== 'swapping') {
                blockData.element.style.transform = `translateY(${-riseOffset}px)`;
            } else {
                 // Ensure transform is reset if it was falling/swapping previously
                 // The specific transitions handle movement, but ensure rise offset isn't applied
                 blockData.element.style.transform = `translateY(0px)`;
            }
        }

        // Dedicated function to update all block visuals, including rise offset
        function updateAllBlockVisualPositions() {
            blocks.forEach(block => {
                if (block.element) {
                    updateBlockVisualPosition(block);
                }
            });
            // Also update cursor position
            renderCursor();
        }


        function renderCursor() {
            // Base position from logical row/col
             const baseX = cursor.col * BLOCK_SIZE;
             const baseY = (VISIBLE_GRID_HEIGHT - 1 - cursor.row) * BLOCK_SIZE;

             cursorElement.style.left = `${baseX}px`;
             cursorElement.style.top = `${baseY}px`;
             // Apply vertical offset for continuous rise
             cursorElement.style.transform = `translateY(${-riseOffset}px)`;
        }

        function updateScoreDisplay() {
            scoreElement.textContent = `Score: ${score}`;
        }

        function updateChainDisplay() {
            chainElement.textContent = `Chain: x${currentChain}`;
        }

        // --- Core Game Loop (Continuous Rise) ---

        function startGameLoop() {
             if (isGameOver) return;
             lastTimestamp = performance.now(); // Use performance.now for higher precision
             animationFrameId = requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            if (isGameOver) {
                animationFrameId = null;
                return;
            }

            const deltaTime = (timestamp - lastTimestamp) / 1000.0; // Delta time in seconds
            lastTimestamp = timestamp;

            // --- Update Rise Offset ---
            riseOffset += currentRiseSpeed * deltaTime;

            // --- Check for Logical Row Commit ---
            let rowsCommitted = 0;
            while (riseOffset >= BLOCK_SIZE) {
                 riseOffset -= BLOCK_SIZE;
                 commitLogicalRise(); // Handle grid shift, new row generation, speed increase etc.
                 rowsCommitted++;
            }

             // --- Update Visuals ---
            // Update all block positions based on the new riseOffset (and potentially new rows if committed)
            updateAllBlockVisualPositions();

             // --- Check Game Over AFTER potential commit ---
             // Game over if a block is *stably* in the buffer row after a commit
             if (rowsCommitted > 0 && checkGameOverCondition()) {
                 triggerGameOver("Block reached top after commit.");
                 return; // Stop loop
             }

            // --- Continue Loop ---
            animationFrameId = requestAnimationFrame(gameLoop);
        }

         // Checks if any non-clearing block exists in the buffer row
        function checkGameOverCondition() {
             for (let c = 0; c < GRID_WIDTH; c++) {
                 const block = grid[GRID_HEIGHT]?.[c]; // Check buffer row (index GRID_HEIGHT)
                 if (block && block.state !== 'clearing' && block.state !== 'flashing') {
                     console.log(`Game over condition met: Block ${block.id} at (${GRID_HEIGHT}, ${c}) state: ${block.state}`);
                     return true;
                 }
             }
             return false;
         }

        // --- Logical Rise Commit ---
        function commitLogicalRise() {
            // console.log("Committing logical rise...");

            // 1. Shift all block data UP (increase row index) & update grid model
            for (let r = GRID_HEIGHT; r >= 0; r--) { // Start from buffer row down
                 for (let c = 0; c < GRID_WIDTH; c++) {
                     const block = grid[r][c];
                     if (block) {
                         block.row++; // Increase logical row
                         // A block moving *into* row GRID_HEIGHT+1 is game over immediately
                         if (block.row > GRID_HEIGHT && block.state !== 'clearing' && block.state !== 'flashing') {
                             // This check should ideally be redundant due to checkGameOverCondition, but good safety net
                             triggerGameOver(`Block ${block.id} pushed beyond buffer row.`);
                             // No need to continue if game over is triggered
                             if(isGameOver) return;
                         }
                     }
                     // Shift grid pointers
                     if (r < GRID_HEIGHT) { // Don't shift *into* row -1
                        grid[r + 1][c] = grid[r][c];
                    } else {
                        // Block previously at grid[GRID_HEIGHT][c] has now moved to row GRID_HEIGHT+1
                        // We don't explicitly track row GRID_HEIGHT+1 in the grid array itself
                    }
                 }
            }

            // 2. Clear the bottom row (row 0) in the grid model
            for(let c = 0; c < GRID_WIDTH; c++) {
                grid[0][c] = null;
            }

            // 3. Generate new row data at the bottom (row 0)
            const newRowBlockData = generateNewRowData(0);

            // 4. Render the *new* blocks ONLY
            newRowBlockData.forEach(renderBlock); // renderBlock now uses updateBlockVisualPosition

            // 5. Increase Rise Speed
            if (currentRiseSpeed < MAX_RISE_SPEED) {
                currentRiseSpeed += SPEED_INCREMENT_ON_COMMIT; // Increase speed per committed row
                currentRiseSpeed = Math.min(currentRiseSpeed, MAX_RISE_SPEED);
                // console.log("Rise speed increased to:", currentRiseSpeed.toFixed(2));
            }

            // 6. IMPORTANT: Immediately update visual 'top' for ALL blocks to reflect their NEW logical rows.
            // The 'transform' offset is already handled, but the base 'top' needs adjustment.
            // This prevents a visual jump when the riseOffset resets.
            // updateAllBlockVisualPositions(); // This is now called in the main loop after commit check

            // 7. Check for matches potentially caused by the new row or shifted blocks
            // Avoid triggering if already processing from a previous action
             if (!isProcessing) {
                checkMatchesAndProcess();
             } else {
                 // console.log("CommitLogicalRise: Skipping match check, processing active.");
             }
        }


        // Generates data only, adds to grid and blocks array, returns new block data
        function generateNewRowData(targetRow) {
             let newRowBlocks = [];
             for (let c = 0; c < GRID_WIDTH; c++) {
                 // Basic check to avoid instant vertical match with block above
                 let type;
                 let attempts = 0;
                 do {
                     type = Math.floor(Math.random() * BLOCK_TYPES);
                     attempts++;
                 } while (
                     attempts < 10 && // Prevent infinite loop in rare cases
                     targetRow > 0 &&
                     grid[targetRow + 1]?.[c] !== null && // Check block directly above
                     grid[targetRow + 1][c].type === type &&
                     grid[targetRow + 1][c].state === 'idle' // Only avoid matching idle blocks
                 );

                 const id = nextBlockId++;
                 const newBlock = {
                     id: id,
                     row: targetRow,
                     col: c,
                     type: type,
                     element: null, // Will be created by renderBlock
                     state: 'idle' // States: 'idle', 'swapping', 'flashing', 'clearing', 'falling'
                 };
                 grid[targetRow][c] = newBlock;
                 blocks.push(newBlock);
                 newRowBlocks.push(newBlock);
             }

             // Prevent instant horizontal matches on the new row itself
             let requiresCheck = true;
             let checkCount = 0; // Safety break
             while (requiresCheck && checkCount < 5) {
                 requiresCheck = false;
                 checkCount++;
                 for (let c = 0; c < GRID_WIDTH - (MIN_MATCH_LENGTH - 1); c++) {
                     const firstBlock = grid[targetRow][c];
                     if (!firstBlock) continue;
                     let match = true;
                     for (let i = 1; i < MIN_MATCH_LENGTH; i++) {
                         if (!grid[targetRow][c + i] || grid[targetRow][c + i].type !== firstBlock.type) {
                             match = false;
                             break;
                         }
                     }
                     if (match) {
                         // Re-roll the type of the first block in the match
                         const currentType = firstBlock.type;
                         let newType;
                         do {
                             newType = Math.floor(Math.random() * BLOCK_TYPES);
                         } while (newType === currentType); // Ensure it's a different type

                         firstBlock.type = newType;
                         // No need to update element class yet, renderBlock hasn't happened
                         requiresCheck = true; // Re-check the row after change
                         c = -1; // Restart check from the beginning of the row
                     }
                 }
             }
             return newRowBlocks; // Return the data for rendering
         }


        function swapBlocks(r, c1, c2) {
             if (isGameOver || c1 < 0 || c1 >= GRID_WIDTH || c2 < 0 || c2 >= GRID_WIDTH || r < 0 || r >= GRID_HEIGHT + 1) { // Check includes buffer row? Let's limit swaps to visible grid.
                 if (r >= GRID_HEIGHT) return; // Don't swap in buffer row or above
                 return;
             }
              if (isProcessing) {
                  console.log("Cannot swap while processing matches/gravity.");
                  return;
              }

             const block1 = grid[r][c1];
             const block2 = grid[r][c2];

             // Prevent swapping blocks that are actively involved in clearing/falling?
             // Tetris Attack allows swapping flashing blocks. Allow falling too? Be careful.
             if ((block1 && (block1.state === 'clearing' /*|| block1.state === 'falling'*/)) ||
                 (block2 && (block2.state === 'clearing' /*|| block2.state === 'falling'*/))) {
                 console.log("Cannot swap clearing blocks.");
                 return;
             }

             console.log(`Swapping (${r},${c1}) and (${r},${c2})`);

             // Update grid model
             grid[r][c1] = block2;
             grid[r][c2] = block1;

             // --- Animation Start ---
             if (block1) {
                 block1.col = c2;
                 block1.state = 'swapping';
                 if (block1.element) {
                     block1.element.classList.add('swapping');
                     updateBlockVisualPosition(block1); // Update left/top, transform will be reset by class/update func
                 }
             }
             if (block2) {
                 block2.col = c1;
                 block2.state = 'swapping';
                 if (block2.element) {
                     block2.element.classList.add('swapping');
                      updateBlockVisualPosition(block2); // Update left/top, transform will be reset by class/update func
                 }
             }

             playSound(swapSound);
             isProcessing = true; // Prevent other actions during swap/fall/check

             // --- After swap animation ---
             setTimeout(() => {
                 // Reset state
                 if (block1) {
                     block1.state = 'idle';
                     if(block1.element) block1.element.classList.remove('swapping');
                 }
                 if (block2) {
                     block2.state = 'idle';
                     if(block2.element) block2.element.classList.remove('swapping');
                 }

                  // Ensure visual positions are correct *after* removing 'swapping' class
                  // and before gravity check.
                 if(block1) updateBlockVisualPosition(block1);
                 if(block2) updateBlockVisualPosition(block2);


                 // Check gravity for the swapped blocks AND blocks above them
                 applyGravity(() => {
                     // After gravity settles (or if none needed), check for matches
                     // `applyGravity` now handles releasing the isProcessing lock AFTER its chain completes
                     checkMatchesAndProcess();
                 });

             }, SWAP_DURATION); // Match the .swapping transition duration
         }


         function checkMatchesAndProcess() {
            if (isProcessing && !activeClearPromises.length) { // Allow checking if processing is only due to pending clears
                 // console.log("Queueing check: Already processing.");
                 return; // Avoid concurrent processing unless it's just waiting for clears
            }
            // Check for Game Over condition (blocks stacked too high and stable) BEFORE finding matches
            if (checkGameOverCondition()) {
                triggerGameOver(`Stable block detected in buffer row before match check.`);
                return; // Stop processing on game over
            }

            isProcessing = true; // Mark start of processing cycle
            // console.log("Checking for matches...");

            const matches = findMatches(); // Find matches using only 'idle' blocks

            if (matches.length > 0) {
                // console.log(`Found ${matches.length} blocks in matches.`);
                currentChain++;
                updateChainDisplay();

                let pointsEarned = 0;
                let basePointsPerBlock = 10;
                let comboBonus = 0; // Bonus for matches > 3
                let chainBonus = currentChain > 1 ? (currentChain - 1) * 50 : 0; // Simple escalating chain bonus

                 const uniqueBlocksToClear = new Set();
                 matches.forEach(matchList => {
                     matchList.forEach(block => {
                         if (block && block.state === 'idle') { // Only add idle blocks to the clear set
                             uniqueBlocksToClear.add(block);
                         } else if (block && (block.state === 'falling' || block.state === 'swapping')) {
                             console.warn(`Match found involving block ${block.id} in state ${block.state}`);
                         }
                     });
                     if (matchList.length > MIN_MATCH_LENGTH) {
                         comboBonus += (matchList.length - MIN_MATCH_LENGTH) * 15; // Example bonus
                     }
                 });

                 if (uniqueBlocksToClear.size === 0) {
                     console.warn("Matches array non-empty, but uniqueBlocksToClear is empty. Match involved non-idle blocks?");
                     isProcessing = false; // Release lock, nothing to clear this cycle
                     return;
                 }

                 pointsEarned = uniqueBlocksToClear.size * basePointsPerBlock + comboBonus + chainBonus;
                 score += pointsEarned;
                 updateScoreDisplay();

                 // Start the two-phase clearing process
                 initiateClearing(Array.from(uniqueBlocksToClear)); // initiateClearing now handles its own promise chain

            } else {
                // No matches found among idle blocks
                // console.log("No matches found.");
                if (currentChain > 0) {
                    // console.log(`Chain ended at x${currentChain}`);
                    currentChain = 0;
                    updateChainDisplay();
                }
                // Crucial: Release the processing lock if no matches are found
                isProcessing = false;
            }
        }


        function findMatches() {
            const allMatches = [];
            const checkedBlocks = new Set();

            // Iterate up to GRID_HEIGHT, buffer row doesn't participate in matching
            for (let r = 0; r < GRID_HEIGHT; r++) {
                for (let c = 0; c < GRID_WIDTH; c++) {
                    const block = grid[r][c];
                    // Only consider IDLE blocks for initiating a match search
                    if (!block || block.state !== 'idle' || checkedBlocks.has(block.id)) {
                        continue;
                    }

                    const blockType = block.type;

                    // Check Horizontal
                    let horizontalMatch = [block];
                    for (let nc = c + 1; nc < GRID_WIDTH; nc++) {
                        const nextBlock = grid[r][nc];
                        // Match blocks even if they are flashing/falling? Tetris Attack allows this.
                        // Let's stick to matching IDLE blocks for now to avoid complexity.
                        // If allowing non-idle: change state check here.
                        if (nextBlock && nextBlock.state === 'idle' && nextBlock.type === blockType) {
                            horizontalMatch.push(nextBlock);
                        } else {
                            break;
                        }
                    }
                    if (horizontalMatch.length >= MIN_MATCH_LENGTH) {
                        allMatches.push(horizontalMatch);
                        horizontalMatch.forEach(b => checkedBlocks.add(b.id));
                    }

                    // Check Vertical (only start check from a block not already in a horizontal match)
                     if (!checkedBlocks.has(block.id)) {
                         let verticalMatch = [block]; // Start fresh check
                         // Iterate up to GRID_HEIGHT
                         for (let nr = r + 1; nr < GRID_HEIGHT; nr++) {
                            const nextBlock = grid[nr][c];
                             if (nextBlock && nextBlock.state === 'idle' && nextBlock.type === blockType) {
                                verticalMatch.push(nextBlock);
                            } else {
                                break;
                            }
                         }
                         if (verticalMatch.length >= MIN_MATCH_LENGTH) {
                            allMatches.push(verticalMatch);
                            // Mark all in this vertical match as checked to avoid redundant checks
                            verticalMatch.forEach(b => checkedBlocks.add(b.id));
                        }
                    }
                }
            }
            // Filter out duplicates across horizontal/vertical groups if necessary
            // For now, initiateClearing uses a Set, handling duplicates naturally.
            return allMatches;
        }

       function initiateClearing(blocksToProcess) {
             // Filter for valid blocks that are still in the grid at their expected location
             const validBlocksToClear = blocksToProcess.filter(b => {
                 return b && b.element && grid[b.row]?.[b.col]?.id === b.id && b.state === 'idle';
             });

             if (validBlocksToClear.length === 0) {
                 // console.log("Initiate Clearing called with no valid idle blocks.");
                 // If no blocks are cleared, gravity check might still be needed if called mid-chain,
                 // but the 'isProcessing' lock should be released eventually.
                 // We rely on the chain: Check -> Clear -> Fall -> Check -> ...
                 // If this step has nothing to clear, the next Fall check will release the lock if needed.
                 applyGravity(() => {
                      // This callback might run if gravity was needed for other reasons.
                      // Ensure processing eventually stops if nothing happened.
                      if (!findMatches().length) { // Double check after potential gravity
                          isProcessing = false;
                            if (currentChain > 0) {
                                // console.log("Chain ended (no valid blocks cleared/fell).")
                                currentChain = 0;
                                updateChainDisplay();
                            }
                      } else {
                          // Matches found AFTER gravity? Restart check.
                           // isProcessing should already be false here if applyGravity completed.
                           checkMatchesAndProcess();
                      }

                 });
                 return;
             }

             console.log(`Initiating clear for ${validBlocksToClear.length} blocks. Chain: ${currentChain}`);
             playSound(clearSound); // Play sound once per clear group start

             // Phase 1: Mark and Flash
             validBlocksToClear.forEach(block => {
                 block.state = 'flashing';
                 block.element.classList.add('flashing');
                 // Ensure rise transform doesn't interfere?
                 // updateBlockVisualPosition(block); // Re-apply visual position might reset flash animation? Test this.
                 // Let's assume CSS animation handles transform correctly.
             });

             const clearPromise = new Promise(resolve => {
                 // Phase 2: Staggered Removal after Flash Delay
                 setTimeout(() => {
                     const sortedBlocks = [...validBlocksToClear].sort((a, b) => {
                         if (a.row !== b.row) return a.row - b.row;
                         return a.col - b.col;
                     });
                     removeBlocksSequentially(sortedBlocks, resolve); // Pass the resolve function
                 }, FLASH_DURATION);
             });

             activeClearPromises.push(clearPromise);

             clearPromise.then(() => {
                 // This specific clear batch (including its gravity check) is done.
                 activeClearPromises = activeClearPromises.filter(p => p !== clearPromise);
                  // Crucially, don't set isProcessing = false here. The gravity check inside
                  // removeBlocksSequentially -> applyGravity handles the next step or releasing the lock.
                  // console.log(`Clear promise resolved. ${activeClearPromises.length} remaining.`);
             }).catch(err => {
                 console.error("Error during clearing process:", err);
                 activeClearPromises = activeClearPromises.filter(p => p !== clearPromise);
                 isProcessing = false; // Force release lock on error
             });
         }


        function removeBlocksSequentially(blocksToRemove, onComplete) {
            const block = blocksToRemove.shift();

            if (block) {
                 const gridBlock = grid[block.row]?.[block.col];
                 // Only remove if it's still the correct block and in a clearing state
                 if(gridBlock && gridBlock.id === block.id && (block.state === 'flashing' || block.state === 'clearing')) {
                    block.state = 'clearing'; // Ensure state
                    if (block.element) {
                        block.element.classList.remove('flashing');
                        // Vanish animation (using opacity and maybe scale via CSS transition)
                        block.element.style.opacity = '0';
                        // Optional: scale down
                        // block.element.style.transform = 'scale(0)'; // Careful: conflicts with rise transform

                        // Remove from DOM after animation
                        setTimeout(() => {
                            block.element.remove();
                        }, 100); // Match vanish animation time (opacity transition)
                    }

                    // Remove from main blocks array
                    const blockIndex = blocks.findIndex(b => b.id === block.id);
                    if (blockIndex > -1) {
                        blocks.splice(blockIndex, 1);
                    } else {
                         console.warn(`Block ${block.id} not found in blocks array during removal.`);
                    }

                    // Nullify in grid model immediately
                    grid[block.row][block.col] = null;

                    // playSound(clearSound); // Moved sound to initiateClearing start

                 } else {
                     console.warn(`Skipping removal of block ${block.id}: Grid mismatch or state changed. State: ${block.state}, Grid: ${gridBlock?.id}`);
                 }
            }

            if (blocksToRemove.length === 0) {
                // All blocks in this batch removed, trigger gravity
                // Use rAF to ensure DOM updates are processed before gravity logic
                requestAnimationFrame(() => {
                     applyGravity(onComplete); // Pass the resolver for the main clear promise
                 });
                 return; // End recursion/sequence here
             } else {
                // Schedule the next removal
                setTimeout(() => removeBlocksSequentially(blocksToRemove, onComplete), INDIVIDUAL_REMOVE_DELAY);
            }
        }


         function applyGravity(onComplete) {
             // console.log("Applying gravity...");
             let blocksFell = false;

             // Iterate bottom-up for each column to handle falling
             for (let c = 0; c < GRID_WIDTH; c++) {
                let writeRow = 0; // Start checking from the bottom row
                // Iterate up to GRID_HEIGHT, buffer row doesn't have gravity applied *to* it
                for (let readRow = 0; readRow < GRID_HEIGHT; readRow++) {
                    const block = grid[readRow][c];
                    if (block !== null) {
                         // Block exists. If its readRow is above its destined writeRow, it needs to fall.
                         if (readRow > writeRow) {
                              // Check if block is clearing - should not happen if logic is correct, but safety first
                             if (block.state === 'clearing' || block.state === 'flashing') {
                                 console.warn(`Block ${block.id} trying to fall while ${block.state}. Skipping fall.`);
                                 // Leave the space empty, block removal handled elsewhere.
                                 grid[readRow][c] = null;
                                 continue; // Don't move it, check next block above
                             }

                             // console.log(`Block ${block.id} at (${readRow}, ${c}) falling to (${writeRow}, ${c})`);
                             blocksFell = true;
                             grid[writeRow][c] = block;   // Move block pointer in grid model
                             grid[readRow][c] = null;     // Clear original spot in grid model

                             block.row = writeRow;       // Update block object's row property
                             block.state = 'falling';

                             if(block.element) {
                                 block.element.classList.add('falling');
                                 // Update visual position - CSS transition on 'top' will handle the animation
                                 // The 'transform' for rise offset is disabled by the 'falling' class style rule
                                 updateBlockVisualPosition(block);
                             } else {
                                 console.warn(`Block ${block.id} is missing its element during gravity.`);
                             }
                         }
                         writeRow++; // Increment writeRow, this is where the *next* block above should land or stay
                     }
                 }
             } // End column loop

             if (blocksFell) {
                 // Wait for falling animation to complete
                 setTimeout(() => {
                     // Reset state of fallen blocks *after* animation
                     blocks.forEach(block => {
                         if (block && block.state === 'falling') {
                             block.state = 'idle';
                             if(block.element) {
                                 block.element.classList.remove('falling');
                                 // Ensure final position is correct, including re-enabling rise transform
                                 updateBlockVisualPosition(block);
                             }
                         }
                     });
                     // console.log("Gravity settled, checking for chain matches...");
                     // Release processing lock *before* next check. If matches found, it will be re-acquired.
                     isProcessing = false;
                     checkMatchesAndProcess(); // Check for new matches (chain reaction)
                     if (onComplete) onComplete(); // Resolve the promise from initiateClearing
                 }, FALL_DURATION); // Wait duration matching CSS transition
             } else {
                 // No blocks fell, process is complete for this cycle
                 // console.log("Gravity applied, no blocks fell.");
                 let matchesExist = false;
                 if(currentChain > 0) {
                     matchesExist = findMatches().length > 0;
                     if (!matchesExist) {
                        // console.log(`Chain ended at x${currentChain} after gravity (no blocks fell).`);
                         currentChain = 0;
                         updateChainDisplay();
                     }
                 }

                 // Release processing lock ONLY if no further matches are found
                 if(!matchesExist) {
                    isProcessing = false;
                 }
                 if (onComplete) onComplete(); // Resolve the promise

                 // If matches *do* exist, trigger the next check immediately
                  if (matchesExist) {
                      // console.log("Matches found after gravity (no fall), re-checking.");
                       checkMatchesAndProcess();
                  }
             }
         }


        function triggerGameOver(reason) {
            if (isGameOver) return; // Prevent multiple triggers
            console.error("Game Over:", reason);
            isGameOver = true;
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            activeClearPromises = []; // Clear any pending clear operations

            // Stop processing flag
            isProcessing = true; // Prevent any further game logic execution

            playSound(gameOverSound);

            finalScoreElement.textContent = `Final Score: ${score}`;
            gameOverOverlay.style.display = 'flex';

             // Stop flashing/falling visuals immediately
            blocks.forEach(b => {
                 if (b.element) {
                     b.element.classList.remove('flashing', 'falling', 'swapping');
                     b.element.style.animation = 'none';
                     b.element.style.transition = 'none'; // Stop ongoing transitions
                     // Optionally force final position if needed
                     updateBlockVisualPosition(b);
                 }
            });
             cursorElement.style.display = 'none'; // Hide cursor
        }

        // --- Input Handling ---
        function handleKeyDown(event) {
             // Handle start/restart universally
             if (startOverlay.style.display === 'flex') {
                  if (event.key === 'Enter' || event.key === ' ') {
                      event.preventDefault();
                      audioContextAllowed = true;
                      initGame();
                  }
                  return;
             }
             if (gameOverOverlay.style.display === 'flex') {
                 if (event.key === 'Enter') {
                     event.preventDefault();
                     initGame();
                 }
                 return;
             }

             // Ignore input if game over state is reached but overlay not yet shown (rare case)
             if (isGameOver) return;

             // Ignore input during block processing (swap, clear, fall)
             if (isProcessing) {
                 console.log("Input ignored: Processing active.");
                 return;
             }


            let moved = false;
            let newRow = cursor.row;
            let newCol = cursor.col;

            switch (event.key) {
                case 'ArrowLeft':
                    if (cursor.col > 0) {
                        newCol--;
                        moved = true;
                    }
                    break;
                case 'ArrowRight':
                    if (cursor.col < GRID_WIDTH - 2) { // Cursor is 2 wide
                        newCol++;
                        moved = true;
                    }
                    break;
                case 'ArrowUp':
                    // Allow cursor up to the top visible row, but not into buffer visually
                    if (cursor.row < GRID_HEIGHT - 1) {
                        newRow++;
                        moved = true;
                    }
                    break;
                case 'ArrowDown':
                    if (cursor.row > 0) {
                        newRow--;
                        moved = true;
                    }
                    break;
                case ' ': // Spacebar
                case 'x': // 'X' key
                case 'X':
                    event.preventDefault();
                    swapBlocks(cursor.row, cursor.col, cursor.col + 1);
                    // Note: checkMatchesAndProcess is called *after* swap animation & gravity
                    break;
                 // DEBUG Keys (Optional)
                 /*
                 case 'p': // Pause/Resume Animation Loop
                     if(animationFrameId) {
                         cancelAnimationFrame(animationFrameId);
                         animationFrameId = null;
                         console.log("Paused Animation");
                     } else if (!isGameOver) {
                         startGameLoop();
                         console.log("Resumed Animation");
                     }
                     break;
                 case 'r': // Force Commit Logical Rise (for testing)
                      if (!isProcessing) {
                           console.log("Forcing Logical Rise Commit");
                           commitLogicalRise();
                           updateAllBlockVisualPositions(); // Ensure visuals update immediately
                           // checkMatchesAndProcess(); // commitLogicalRise already calls this
                      } else {
                           console.log("Cannot force rise while processing.");
                      }
                      break;
                */
            }

            if (moved) {
                 cursor.row = newRow;
                 cursor.col = newCol;
                 renderCursor(); // Update cursor position immediately
            }

            // Prevent arrow keys/space from scrolling the page
             if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' '].includes(event.key)) {
                event.preventDefault();
             }
        }


        // --- Event Listeners ---
        document.addEventListener('keydown', handleKeyDown);

        restartButton.addEventListener('click', () => {
            // No need to hide overlay, initGame does it
            initGame();
        });

        startButton.addEventListener('click', () => {
             audioContextAllowed = true;
             swapSound.load(); // Preload attempt
             clearSound.load();
             gameOverSound.load();
             initGame();
        });

        // --- Touch/Mouse Controls ---
        // Basic Tap-to-Move-Cursor and Tap-Pair-to-Swap
        let firstTap = null;
        gameBoard.addEventListener('click', (event) => {
            if (isGameOver || startOverlay.style.display === 'flex' || isProcessing) return;
            if (!audioContextAllowed) {
                audioContextAllowed = true;
                swapSound.load(); clearSound.load(); gameOverSound.load();
            }

            const rect = gameBoard.getBoundingClientRect();
            const x = event.clientX - rect.left;
            // Adjust Y coord based on current rise offset
            const y = event.clientY - rect.top + riseOffset;

            const col = Math.floor(x / BLOCK_SIZE);
            // Calculate logical row based on adjusted Y
            const row = VISIBLE_GRID_HEIGHT - 1 - Math.floor(y / BLOCK_SIZE);


             if (col < 0 || col >= GRID_WIDTH || row < 0 || row >= GRID_HEIGHT) return; // Click outside logical grid

             // --- Simple Tap-to-Swap Logic ---
             // If tap is on the block pair currently under the cursor, perform swap
             if (row === cursor.row && (col === cursor.col || col === cursor.col + 1)) {
                 console.log("Tapped cursor location - swapping");
                 swapBlocks(cursor.row, cursor.col, cursor.col + 1);
                 firstTap = null; // Clear any previous tap sequence
             }
             // Otherwise, move the cursor to the tapped location
             else {
                 console.log(`Tapped: (${row}, ${col}). Moving cursor.`);
                 cursor.row = row;
                 // Ensure cursor's left edge (col) doesn't go beyond second-to-last column
                 cursor.col = Math.min(col, GRID_WIDTH - 2);
                 renderCursor();
                 firstTap = null; // Clear any previous tap sequence on move
             }

             /* // --- Alternative: Two-Tap Swap Logic (More Complex) ---
             if (!firstTap) {
                 firstTap = { row, col };
                 console.log("First tap:", firstTap);
                 // Optional: Highlight first tap? Needs element access.
                 // Move cursor to selection
                  cursor.row = row;
                  cursor.col = Math.min(col, GRID_WIDTH - 2);
                  renderCursor();

             } else {
                 const dr = Math.abs(row - firstTap.row);
                 const dc = Math.abs(col - firstTap.col);

                 if (dr === 0 && dc === 1) { // Horizontally adjacent
                     console.log("Second tap adjacent horizontally - swapping");
                     // Ensure correct order for swap function
                     swapBlocks(row, Math.min(firstTap.col, col), Math.max(firstTap.col, col));
                     firstTap = null; // Reset tap
                 } else {
                     console.log("Second tap not adjacent or vertical. Resetting.");
                      // Treat as new first tap
                      firstTap = { row, col };
                      // Move cursor to new selection
                      cursor.row = row;
                      cursor.col = Math.min(col, GRID_WIDTH - 2);
                      renderCursor();
                 }
             }
             // Clear firstTap after a delay if no second tap occurs? Might be annoying.
             */
        });


        // --- Initial Setup ---
        startOverlay.style.display = 'flex';
        cursorElement.style.display = 'none'; // Hide cursor until game starts

    </script>
</body>
</html>